## Ecrire un script Pyhton pour IDA qui doit donner la liste de toutes les instruction ``xor`` qui ne sont pas des ``xor`` de remise à zero et qui sont dans une boucle.

* Commentaires (explication des algorithme)
* Limites du code

```python
heads = list(Heads()) # création de la liste des instruction
debut = []  # tablea contenant l'adresse de début de boucle
fin = [] # tablea contenant l'adresse de fin de boucle
for head in heads: # pour chaque instruction
    if GetMnem(head) in ['jmp', 'jnz', 'jz']:   # on regarde si c'est un jump (à améliorer pour ajouter les différents jumps)
        if "short" in GetDisasm(head):  # on regarde si c'est un jump "short"
            if LocByName(GetOpnd(head,0)) < head:   # on regarde si la cible se trouve avant le jump
                debut.append(LocByName(GetOpnd(head,0)))    # on ajoute le debut de la boucle
                fin.append(head)    # et la fin

xors = []   # liste des xor
for head in heads:  # pour chaque isntruction
    if GetMnem(head) == 'xor':  # on regarde si c'est un xor
        if GetOpnd(head,0) != GetOpnd(head,1):  # et si ce n'est pas un xor de remise à zero
            for index, item in enumerate(debut): # on regarde si le xor se trouve dans une boucle i.e. entre un debut un la fin associé
                if head >= debut[index] & head <= fin[index]:
                    xors.append(head)
                    print(hex(head))
                    SetColor(head, CIC_ITEM, 0xFF00FF)
                    break

    
```

Limites
* Impossible si le code et caché (dans un char*)
* Impossible si obfuscation des boucles (jump très long pour revenir à la boucle après)