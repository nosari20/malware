# Projet analysé : Mounia Valéry

## But
Détecter : 
* L'instruction qui fait l'impression (Adresse)
* Chiffrement (Algorithme, clés)
* Code mort, code qui ne sert à rien
* Anti-debug
* Auto-modification (qui produit le nouveau code, que fait le nouveau code)

## Comportement

### En mode normal 
```
Je suis un virus
```
### En mode debug
```
Je suis gentil
```
## Analyse

Pour commencer, nous avons tout simplement utilisé la fenêtre ``Imports`` d'IDA de façon à voir si des fonctions "sensibles" étaient utilisées.

### Anti-debug
À l'aide de la fenêtre ``Imports`` nous avons pu voir la présence d'un debugger avec ``IsDebuggerPresent``. Si le debugger est présent alors le programme continue et se termine avec l'affichage de ``Je suis gentil`` à l'aide de la fonction ``printf``  sinon il va à l'instruction: ``loc_4113DD``.
```assembly
mov     esi, esp
call    ds:IsDebuggerPresent
cmp     esi, esp
call    sub_411136
test    eax, eax
jz     short loc_4113DD
mov     esi, esp
push    offset Format   ; "Je suis tres gentil"
call    ds:printf
```

Afin de bypasser cette protection nous avons tout simplement remplacé le ``jz     short loc_4113DD`` par ``jnz     short loc_4113DD``.
### Affichage
Par la suite on constate l'utilisation de la fonction ``int puts(const char *str)``, il est bon de noter que cette fonction prend un seul argument. Ensuite dans l'étiquette ``loc_41148B`` on voit une succession de 2 ``push`` suivis d'un ``call`` avec ``%c`` comme opérande du deuxième ``push`` ce qui signifie qu'il y a l'utilisation d'une fonction de la forme ``func("%c",XXX)`` ce qui peut rappeler la fonction ``int printf(const char *format, ...)`` avec laquelle on voudrait afficher un caractère. On constate que cet appel s'effectue dans une boucle qui est appelée 16 fois et change le contenu de l'operande du premier ``push``. Nous constatons aussi que si l'on change la valeur de la deuxième operande de l'instruction ``cmp [ebp+var_5C], 10h`` alors seule une partie du message sera affichée donc l'affichage vient bien de cette partie (on peut aussi utiliser les breakpoints dans IDA en replaçant ``jz short loc_4113DD`` par ``jnz short loc_4113DD`` dans la partie qui verifie la présence de debugger). Il reste ensuite à comprendre comment est appelé ``printf``. Avant la boucle, d'affichage on constate qu'un certain nombre d'opération est appliqué sur ``eax`` qui contient en fait ``puts``. On en déduit donc ``eax = puts - 688`` ou en hexadécimal ``eax = puts - 2B0`` et on sauvegarde le contenu de ``eax`` à l'adresse ``[ebp+var_44]``. ``ebp`` n'étant pas changé avant l'appel on peut donc en conclure que ``printf`` est obtenu à l'aide de ``puts``.
On en conlue donc que l'adresse du printf est: ``004114A3``.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
.text:0041146B                 mov     eax, ds:puts                 ; fonction puts(char *)
.text:00411470                 mov     [ebp+var_50], eax
.text:00411473                 mov     eax, [ebp+var_50]
.text:00411476                 sub     eax, 2B0h
.text:0041147B                 mov     [ebp+var_50], eax
.text:0041147E                 mov     eax, [ebp+var_50]            ; eax = puts - 688
.text:00411481                 mov     [ebp+var_44], eax            
.text:00411484                 mov     [ebp+var_5C], 0
.text:0041148B
.text:0041148B loc_41148B:                             ; CODE XREF: sub_411390+129j
.text:0041148B                 cmp     [ebp+var_5C], 10h            ; while([ebp+var_5C] <= 16)
.text:0041148F                 jge     short loc_4114BB
.text:00411491                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:00411494                 movsx   ecx, byte_417000[eax]        ; ecx = byte_417000[eax]
.text:0041149B                 mov     esi, esp                     
.text:0041149D                 push    ecx                          ; met ecx en haut de la pile
.text:0041149E                 push    offset unk_41573C            ; met "%c" en haut de la pile 
.text:004114A3                 call    [ebp+var_44]                 ; printf("%c",ecx) 
.text:004114A6                 add     esp, 8                       
.text:004114A9                 cmp     esi, esp
.text:004114AB                 call    sub_411136
.text:004114B0                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:004114B3                 add     eax, 1                       ; eax += 1
.text:004114B6                 mov     [ebp+var_5C], eax            ; [ebp+var_5C] = eax
.text:004114B9                 jmp     short loc_41148B             ; continue la boucle
```
### Chiffrement du message
On constate dans la boucle d'affichage que le texte est stocké dans ``byte_417000`` est déjà déchiffrée, donc le déchiffrement se fait avant.

### Code caché

Dans le code ci-desssous il y a 2 boucles qui modifient ``byte_417010`` et ``byte_417018``. On s'apperçoit que dans la suite du code ces octets sont exécutés, on peut donc imaginer qu'une partie du code est cachée ici.

```assembly
.text:004113EF loc_4113EF:                             ; CODE XREF: sub_411390+54j
.text:004113EF                 cmp     [ebp+var_8], 9
.text:004113F3                 jge     short loc_411435
.text:004113F5                 cmp     [ebp+var_8], 8
.text:004113F9                 jge     short loc_411417
.text:004113FB                 mov     eax, [ebp+var_8]
.text:004113FE                 movsx   ecx, byte_417010[eax]
.text:00411405                 xor     ecx, 12h
.text:00411408                 and     ecx, 0FFh
.text:0041140E                 mov     edx, [ebp+var_8]
.text:00411411                 mov     byte_417010[edx], cl
.text:00411417
.text:00411417 loc_411417:                             ; CODE XREF: sub_411390+69j
.text:00411417                 mov     eax, [ebp+var_8]
.text:0041141A                 movsx   ecx, byte_417018[eax]
.text:00411421                 xor     ecx, 12h
.text:00411424                 and     ecx, 0FFh
.text:0041142A                 mov     edx, [ebp+var_8]
.text:0041142D                 mov     byte_417018[edx], cl
.text:00411433                 jmp     short loc_4113E6
.text:00411435 ; ---------------------------------------------------------------------------
.text:00411435
.text:00411435 loc_411435:                             ; CODE XREF: sub_411390+63j
.text:00411435                 mov     [ebp+var_14], offset byte_417010
.text:0041143C                 mov     [ebp+var_20], offset byte_417018
.text:00411443                 mov     esi, esp
.text:00411445                 call    [ebp+var_20]
.text:00411448                 cmp     esi, esp
.text:0041144A                 call    sub_411136
.text:0041144F                 mov     [ebp+var_2C], eax
.text:00411452
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
````
* Code dans ``byte_417010 ([ebp+var_14])``
```assembly
0:  80 f3 42                xor    bl,0x42
3:  88 1c 08                mov    BYTE PTR [eax+ecx*1],bl
6:  41                      inc    ecx
7:  c3                      ret
```
* Code dans ``byte_417018 ([ebp+var_20])``
```assembly
0:  33 c9                   xor    ecx,ecx
2:  8d 05 00 70 41 00       lea    eax,ds:0x417000
8:  c3                      ret
```

La boucle ci-dessous correpond au déchifrement, on peut le verifier avec le debugger. Il ne reste plus qu'a comprendre comment à l'aide du code ci-dessu.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
```
L'agorithme de déchiffrement est le suivant :
```
eax = byte_417000
ecx = 0
tant que  ecx < 16
    bl = eax[ecx]
    bl -= 1
    { // block de code de byte_417010 
        bl = bl ^ 0x42
        eax[ecx] = bl
        ecx += 1
    }
ftantque
```
