# Projet analysé : Mounia Valéry

## But
Détecter : 
* Anti-debug
* L'instruction qui fait l'impression (Adresse)
* Chiffrement (Algorithme, clés)
* Code mort, code qui ne sert à rien
* Auto-modification (qui produit le nouveau code, que fait le nouveau code)

## Comportement

### En mode normal 
```
Je suis un virus
```
### En mode debug
```
Je suis gentil
```
## Analyse

Pour commencer, nous avons tout simplement utilisé la fenêtre ``Imports`` d'IDA de façon à voir si des fonctions "sensibles" étaient utilisées.

### Anti-debug
À l'aide de la fenêtre ``Imports`` nous avons pu voir que le programme testait la présence d'un debugger avec ``IsDebuggerPresent``.Si le debugger est présent alors le programme affiche ``Je suis gentil`` via ``printf`` puis termine sinon le programme continue à l'étiquette: ``loc_4113DD``.
```assembly
mov     esi, esp
call    ds:IsDebuggerPresent
cmp     esi, esp
call    sub_411136
test    eax, eax
jz     short loc_4113DD
mov     esi, esp
push    offset Format   ; "Je suis tres gentil"
call    ds:printf
```

Afin de bypasser cette protection nous avons tout simplement remplacé le ``jz     short loc_4113DD`` par ``jmp     short loc_4113DD``.

### Affichage
Toujours à l'aide de la fenêtre ``Imports`` nous constatons la présence de la fonction ``int puts(const char *str)``, cependant nous ne trouvons aucun ``call`` correspondant.
Néanmoins nous remarquons qu'avant la boucle qui effectue les affichages (i.e ``loc_411452``), un certain nombre d'opérations est appliqué sur ``eax`` qui contient l'adresse de ``puts``. Nous supposons donc qu'ils se sont servis de l'adresse de ``puts``(en lui soustrayant 688) pour atteindre l'adresse de la fonction ``printf``. Et donc ``[ebp+var_44], eax`` pointerait directement sur ``printf``.
Et notre hypothèse était correcte car dans l'étiquette ``loc_41148B`` nous pouvons voir une succession de 2 ``push`` suivis d'un ``call`` avec ``%c`` comme opérande du deuxième ``push`` ce qui signifie qu'il y a l'utilisation d'une fonction de la forme ``func("%c",XXX)`` ce qui confirme notre hypothèse par rapport à la fonction ``int printf(const char *format, ...)``.

En analysant le code, nous remarquons donc qu'ils se servent de ``printf`` pour afficher chaque caractère de ``Je suis un virus`` car si nous modifions le nombre d'itérations en modifiant la deuxième opérande de ``cmp [ebp+var_5C], 10h`` les phrases ne sera pas affiché en entière. 

Nous pouvons conclure en disant qu'ils se sont servis de ``puts`` pour atteindre ``printf`` et qu'ils affichent caractère par caractère le contenu de leur message, et donc l'adresse de leur fonction d'affichage est: ``004114A3``.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
.text:0041146B                 mov     eax, ds:puts                 ; fonction puts(char *)
.text:00411470                 mov     [ebp+var_50], eax			; [ebp+var_50] = ds:puts
.text:00411473                 mov     eax, [ebp+var_50]			; eax, ds:puts
.text:00411476                 sub     eax, 2B0h					; eax = ds:puts - 2B0 (688)
.text:0041147B                 mov     [ebp+var_50], eax			; [ebp+var_50] = eax
.text:0041147E                 mov     eax, [ebp+var_50]            
.text:00411481                 mov     [ebp+var_44], eax            ; [ebp+var_44] = eax (ds:puts - 2B0)
.text:00411484                 mov     [ebp+var_5C], 0
.text:0041148B
.text:0041148B loc_41148B:                             ; CODE XREF: sub_411390+129j
.text:0041148B                 cmp     [ebp+var_5C], 10h            ; while([ebp+var_5C] <= 16)
.text:0041148F                 jge     short loc_4114BB
.text:00411491                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:00411494                 movsx   ecx, byte_417000[eax]        ; ecx = byte_417000[eax]
.text:0041149B                 mov     esi, esp                     
.text:0041149D                 push    ecx                          ; met ecx en haut de la pile
.text:0041149E                 push    offset unk_41573C            ; met "%c" en haut de la pile 
.text:004114A3                 call    [ebp+var_44]                 ; printf("%c",ecx) 
.text:004114A6                 add     esp, 8                       
.text:004114A9                 cmp     esi, esp
.text:004114AB                 call    sub_411136
.text:004114B0                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:004114B3                 add     eax, 1                       ; eax += 1
.text:004114B6                 mov     [ebp+var_5C], eax            ; [ebp+var_5C] = eax
.text:004114B9                 jmp     short loc_41148B             ; continue la boucle
```
### Chiffrement du message

À l'étape précédente nous nous étions rendu compte que le message était stocké dans ``byte_417000`` et que ce dernier était déjà déchiffré.
On constate dans la boucle d'affichage que le texte est stocké dans ``byte_417000`` est déjà déchiffrée, donc le déchiffrement se fait avant.
Cependant en cherchant dans le code nous n'avons pas trouvé d'endroit où était utilisé ``byte_417000`` clairement, or nous savons que à l'état initial les octets stockés dans ``byte_417000`` sont chiffrés.
Il y a donc un moment dans leur code où ces octets doivent être déchiffrés.

En analysant le code nous remarquons que le déchiffrement est effectué dans l'étiquette: ``loc_411452``, et c'est plus précisement le ``call    [ebp+var_14]`` qui effectue cette fonction.
Nous remarquons donc que notre d'hypothèse semble vérifiée, et (grâce à IDA et aux breakpoints) ``mov     [ebp+var_14], offset byte_417010`` or nous savons également (en comparant avec l'état initial) que le contenu de ``byte_417010`` nécessite également d'être déchiffré.

### Code caché

Dans le code ci-desssous il y a 2 boucles qui modifient ``byte_417010`` et ``byte_417018``. On s'apperçoit que dans la suite du code ces octets sont exécutés, on peut donc imaginer qu'une partie du code est cachée ici.

```assembly
.text:004113EF loc_4113EF:                             ; CODE XREF: sub_411390+54j
.text:004113EF                 cmp     [ebp+var_8], 9
.text:004113F3                 jge     short loc_411435
.text:004113F5                 cmp     [ebp+var_8], 8
.text:004113F9                 jge     short loc_411417
.text:004113FB                 mov     eax, [ebp+var_8]
.text:004113FE                 movsx   ecx, byte_417010[eax]
.text:00411405                 xor     ecx, 12h
.text:00411408                 and     ecx, 0FFh
.text:0041140E                 mov     edx, [ebp+var_8]
.text:00411411                 mov     byte_417010[edx], cl
.text:00411417
.text:00411417 loc_411417:                             ; CODE XREF: sub_411390+69j
.text:00411417                 mov     eax, [ebp+var_8]
.text:0041141A                 movsx   ecx, byte_417018[eax]
.text:00411421                 xor     ecx, 12h
.text:00411424                 and     ecx, 0FFh
.text:0041142A                 mov     edx, [ebp+var_8]
.text:0041142D                 mov     byte_417018[edx], cl
.text:00411433                 jmp     short loc_4113E6
.text:00411435 ; ---------------------------------------------------------------------------
.text:00411435
.text:00411435 loc_411435:                             ; CODE XREF: sub_411390+63j
.text:00411435                 mov     [ebp+var_14], offset byte_417010
.text:0041143C                 mov     [ebp+var_20], offset byte_417018
.text:00411443                 mov     esi, esp
.text:00411445                 call    [ebp+var_20]
.text:00411448                 cmp     esi, esp
.text:0041144A                 call    sub_411136
.text:0041144F                 mov     [ebp+var_2C], eax
.text:00411452
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
````
* Code dans ``byte_417010 ([ebp+var_14])``
```assembly
0:  80 f3 42                xor    bl,0x42
3:  88 1c 08                mov    BYTE PTR [eax+ecx*1],bl
6:  41                      inc    ecx
7:  c3                      ret
```
* Code dans ``byte_417018 ([ebp+var_20])``
```assembly
0:  33 c9                   xor    ecx,ecx
2:  8d 05 00 70 41 00       lea    eax,ds:0x417000
8:  c3                      ret
```

La boucle ci-dessous correpond au déchifrement, on peut le verifier avec le debugger. Il ne reste plus qu'a comprendre comment à l'aide du code ci-dessu.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
```
L'agorithme de déchiffrement est le suivant :
```
eax = byte_417000
ecx = 0
tant que  ecx < 16
    bl = eax[ecx]
    bl -= 1
    { // block de code de byte_417010 
        bl = bl ^ 0x42
        eax[ecx] = bl
        ecx += 1
    }
ftantque
```
Code IDA Python de déchiffrement
```python
Code IDA Python de déchiffrement
```python
chiffre = []
debut = LocByName("byte_417000")
fin = LocByName("byte_417010")-1
courant = debut
i = 0;
while courant != fin : 
	courant = debut + i
	chiffre.append(Byte(courant))
	i+=1
for c in chiffre :
	print(chr((c - 1) ^ 0x42))
```
