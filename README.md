# Projet analysé : Mounia Valéry

## But
Détecter : 
* L'instruction qui fait l'impression (Adresse)
* Chiffrement (Algorithme, clés)
* Code mort, code qui ne sert à rien
* Anti-debug
* Auto-modification (qui produit le nouveau code, que fait le nouveau code)

## Comportement

### En mode normal 
```
Je suis un virus
```
### En mode debug
```
Je suis gentil
```
## Analyse

### Anti-debug
Dans les lignes ci-desous on constate que le programme verifie la présence d'un debugger avec ``IsDebuggerPresent``. Si le debugger est présent le programme continue et se termine avec l'affichage de ``Je suis gentil`` à l'aide de la fonction ``printf``  sinon il va à l'instruction à l'adresse ``loc_4113DD``.
```assembly
mov     esi, esp
call    ds:IsDebuggerPresent
cmp     esi, esp
call    sub_411136
test    eax, eax
jz     short loc_4113DD
mov     esi, esp
push    offset Format   ; "Je suis tres gentil"
call    ds:printf
```
### Affichage
Par la suite on constate l'utilisation de la fonction ``int puts(const char *str)``, il est bon de noté que cette fonction prend un seul argument. Ensuite on voit une succession de 2 ``push`` suivis d'un ``call`` avec ``%c`` comme operande du deuxième ``push`` ce qui signifie qu'il y a l'utilisation d'une fonction de la forme ``func("%c",XXX)`` ce qui peut rappeler la fonction ``int printf(const char *format, ...)`` avec laquelle on voudrait afficher un caractère. On constate ensuite une boucle autour de l'appel de cette fonction, cette boucle est appelé 16 fois et change le contenu de l'operande du premier ``push``. Il est bon de constater que si l'on change la valeur de la deuxième operande de l'instruction ``cmp [ebp+var_5C], 10h`` seul une partie du message est affiché donc l'affichage viens bien de cette partie (on peut aussi utiliser les breakpoints dans IDA en replaçant ``jz short loc_4113DD`` par ``jnz short loc_4113DD`` dans la partie qui verifie la présence de debugger). Il reste ensuite à comprendre comment est appelé ``printf``. Avant la boucle, d'affichage on constate qu'un certain nombre d'opération est appliqué sur ``eax`` qui contient en fait ``puts``. On en arrive à ``eax = puts - 688`` et on stock le contenu de ``eax`` à l'adresse ``[ebp+var_44]``. ``ebp`` n'étant pas changé avant l'appel on peut donc en conclure que ``printf`` est obtenu à l'aide de ``puts``.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
.text:0041146B                 mov     eax, ds:puts                 ; fonction puts(char *)
.text:00411470                 mov     [ebp+var_50], eax
.text:00411473                 mov     eax, [ebp+var_50]
.text:00411476                 sub     eax, 2B0h
.text:0041147B                 mov     [ebp+var_50], eax
.text:0041147E                 mov     eax, [ebp+var_50]            ; eax = puts - 688
.text:00411481                 mov     [ebp+var_44], eax            
.text:00411484                 mov     [ebp+var_5C], 0
.text:0041148B
.text:0041148B loc_41148B:                             ; CODE XREF: sub_411390+129j
.text:0041148B                 cmp     [ebp+var_5C], 10h            ; while([ebp+var_5C] <= 16)
.text:0041148F                 jge     short loc_4114BB
.text:00411491                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:00411494                 movsx   ecx, byte_417000[eax]        ; ecx = byte_417000[eax]
.text:0041149B                 mov     esi, esp                     
.text:0041149D                 push    ecx                          ; met ecx en haut de la pile
.text:0041149E                 push    offset unk_41573C            ; met "%c" en haut de la pile 
.text:004114A3                 call    [ebp+var_44]                 ; printf("%c",ecx) 
.text:004114A6                 add     esp, 8                       
.text:004114A9                 cmp     esi, esp
.text:004114AB                 call    sub_411136
.text:004114B0                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:004114B3                 add     eax, 1                       ; eax += 1
.text:004114B6                 mov     [ebp+var_5C], eax            ; [ebp+var_5C] = eax
.text:004114B9                 jmp     short loc_41148B             ; continue la boucle
```
### Chiffrement du message
On consate dans la boucle d'affichage que le texte est stocké dans ``byte_417000`` et le debugger le confirme.

### Code caché

Dans le code ci-desssous il y a 2 boucles qui modifies ``byte_417010`` et ``byte_417018``. On s'apperçoit que dans la suite du code ces octets sont exécutés, on peut donc imaginer qu'une partie du code est caché ici.

```assembly
.text:004113EF loc_4113EF:                             ; CODE XREF: sub_411390+54j
.text:004113EF                 cmp     [ebp+var_8], 9
.text:004113F3                 jge     short loc_411435
.text:004113F5                 cmp     [ebp+var_8], 8
.text:004113F9                 jge     short loc_411417
.text:004113FB                 mov     eax, [ebp+var_8]
.text:004113FE                 movsx   ecx, byte_417010[eax]
.text:00411405                 xor     ecx, 12h
.text:00411408                 and     ecx, 0FFh
.text:0041140E                 mov     edx, [ebp+var_8]
.text:00411411                 mov     byte_417010[edx], cl
.text:00411417
.text:00411417 loc_411417:                             ; CODE XREF: sub_411390+69j
.text:00411417                 mov     eax, [ebp+var_8]
.text:0041141A                 movsx   ecx, byte_417018[eax]
.text:00411421                 xor     ecx, 12h
.text:00411424                 and     ecx, 0FFh
.text:0041142A                 mov     edx, [ebp+var_8]
.text:0041142D                 mov     byte_417018[edx], cl
.text:00411433                 jmp     short loc_4113E6
.text:00411435 ; ---------------------------------------------------------------------------
.text:00411435
.text:00411435 loc_411435:                             ; CODE XREF: sub_411390+63j
.text:00411435                 mov     [ebp+var_14], offset byte_417010
.text:0041143C                 mov     [ebp+var_20], offset byte_417018
.text:00411443                 mov     esi, esp
.text:00411445                 call    [ebp+var_20]
.text:00411448                 cmp     esi, esp
.text:0041144A                 call    sub_411136
.text:0041144F                 mov     [ebp+var_2C], eax
.text:00411452
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
````
* Code dans ``byte_417010 ([ebp+var_14])``
```assembly
0:  80 f3 42                xor    bl,0x42                  ; bl = ebx
3:  88 1c 08                mov    BYTE PTR [eax+ecx*1],bl  ; 
6:  41                      inc    ecx
7:  c3                      ret
```
* Code dans ``byte_417018 ([ebp+var_20])``
```assembly
0:  0c 98                   or     al,0x98
2:  d5 07                   aad    0x7
4:  04 10                   add    al,0x10
6:  0c 30                   or     al,0x30
8:  00 00                   add    BYTE PTR [eax],al
```

La boucle ci-dessous correpond au déchifrement, on peut le verifier avec le debugger. Il ne reste plus qu'a comprendre comment à l'aide du code ci-dessu.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
```
L'agorithme de déchiffrement est le suivant :
```
eax = byte_417000
ecx = 0
tant que  ecx < 16
    bl = eax[ecx]
    bl -= 1
    { // block de code de byte_417010 
        bl = bl ^ 0x42
        eax[ecx] = bl
        ecx += 1
    }
ftantque
```
