# Projet analysé : Mounia Valéry

## But
Détecter : 
* Anti-debug
* L'instruction qui fait l'impression (Adresse)
* Chiffrement (Algorithme, clés)
* Code mort, code qui ne sert à rien
* Auto-modification (qui produit le nouveau code, que fait le nouveau code)

## Comportement

### En mode normal 
```
Je suis un virus
```
### En mode debug
```
Je suis gentil
```
## Analyse

Pour commencer, nous avons tout simplement utilisé la fenêtre ``Imports`` d'IDA de façon à voir si des fonctions "sensibles" étaient utilisées.

### Anti-debug
À l'aide de la fenêtre ``Imports`` nous avons pu voir que le programme testait la présence d'un debugger avec ``IsDebuggerPresent``.Si le debugger est présent alors le programme affiche ``Je suis gentil`` via ``printf`` puis termine sinon le programme continue à l'étiquette: ``loc_4113DD``.
```assembly
mov     esi, esp
call    ds:IsDebuggerPresent
cmp     esi, esp
call    sub_411136
test    eax, eax
jz     short loc_4113DD
mov     esi, esp
push    offset Format   ; "Je suis tres gentil"
call    ds:printf
```

Afin de bypasser cette protection nous avons tout simplement remplacé le ``jz     short loc_4113DD`` par ``jmp     short loc_4113DD``.

### Affichage
Toujours à l'aide de la fenêtre ``Imports`` nous constatons la présence de la fonction ``int puts(const char *str)``, cependant nous ne trouvons aucun ``call`` correspondant.
Néanmoins nous remarquons qu'avant la boucle qui effectue les affichages (i.e ``loc_411452``), un certain nombre d'opérations est appliqué sur ``eax`` qui contient l'adresse de ``puts``. Nous supposons donc qu'ils se sont servis de l'adresse de ``puts``(en lui soustrayant 688) pour atteindre l'adresse de la fonction ``printf``. Et donc ``[ebp+var_44], eax`` pointerait directement sur ``printf``.
Et notre hypothèse était correcte car dans l'étiquette ``loc_41148B`` nous pouvons voir une succession de 2 ``push`` suivis d'un ``call`` avec ``%c`` comme opérande du deuxième ``push`` ce qui signifie qu'il y a l'utilisation d'une fonction de la forme ``func("%c",XXX)`` ce qui confirme notre hypothèse par rapport à la fonction ``int printf(const char *format, ...)``.

En analysant le code, nous remarquons donc qu'ils se servent de ``printf`` pour afficher chaque caractère de ``Je suis un virus`` car si nous modifions le nombre d'itérations en modifiant la deuxième opérande de ``cmp [ebp+var_5C], 10h`` les phrases ne sera pas affiché en entière. 

Nous pouvons conclure en disant qu'ils se sont servis de ``puts`` pour atteindre ``printf`` et qu'ils affichent caractère par caractère le contenu de leur message, et donc l'adresse de leur fonction d'affichage est: ``0x04114A3``.
```assembly
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
.text:0041146B                 mov     eax, ds:puts                 ; fonction puts(char *)
.text:00411470                 mov     [ebp+var_50], eax			; [ebp+var_50] = ds:puts
.text:00411473                 mov     eax, [ebp+var_50]			; eax, ds:puts
.text:00411476                 sub     eax, 2B0h					; eax = ds:puts - 2B0 (688)
.text:0041147B                 mov     [ebp+var_50], eax			; [ebp+var_50] = eax
.text:0041147E                 mov     eax, [ebp+var_50]            
.text:00411481                 mov     [ebp+var_44], eax            ; [ebp+var_44] = eax (ds:puts - 2B0)
.text:00411484                 mov     [ebp+var_5C], 0
.text:0041148B
.text:0041148B loc_41148B:                             ; CODE XREF: sub_411390+129j
.text:0041148B                 cmp     [ebp+var_5C], 10h            ; while([ebp+var_5C] <= 16)
.text:0041148F                 jge     short loc_4114BB
.text:00411491                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:00411494                 movsx   ecx, byte_417000[eax]        ; ecx = byte_417000[eax]
.text:0041149B                 mov     esi, esp                     
.text:0041149D                 push    ecx                          ; met ecx en haut de la pile
.text:0041149E                 push    offset unk_41573C            ; met "%c" en haut de la pile 
.text:004114A3                 call    [ebp+var_44]                 ; printf("%c",ecx) 
.text:004114A6                 add     esp, 8                       
.text:004114A9                 cmp     esi, esp
.text:004114AB                 call    sub_411136
.text:004114B0                 mov     eax, [ebp+var_5C]            ; eax = [ebp+var_5C]
.text:004114B3                 add     eax, 1                       ; eax += 1
.text:004114B6                 mov     [ebp+var_5C], eax            ; [ebp+var_5C] = eax
.text:004114B9                 jmp     short loc_41148B             ; continue la boucle
```
### Chiffrement du message

À l'étape précédente nous nous étions rendu compte que le message était stocké dans ``byte_417000`` et que ce dernier était déjà déchiffré.
On constate dans la boucle d'affichage que le texte est stocké dans ``byte_417000`` est déjà déchiffrée, donc le déchiffrement se fait avant.
Cependant en cherchant dans le code nous n'avons pas trouvé d'endroit où était clairement utilisé ``byte_417000``, or nous savons qu'à l'état initial les octets stockés dans ``byte_417000`` sont chiffrés.
Il y a donc un moment dans leur code où ces octets doivent être déchiffrés.

En analysant le code nous remarquons que le déchiffrement est effectué dans l'étiquette: ``loc_411452``, et c'est plus précisement le ``call    [ebp+var_14]`` qui effectue cette fonction.
Nous remarquons donc que notre d'hypothèse semble vérifiée, et (grâce à IDA et aux breakpoints) ``mov     [ebp+var_14], offset byte_417010`` or nous savons également (en comparant avec l'état initial) que le contenu de ``byte_417010`` nécessite également d'être déchiffré. 
Nous reviendrons sur ce point dans la partie suivante (pour déchiffré ``byte_417010`` et ``byte_417018``).

Nous savons donc maintenant que le contenu de ``byte_417010`` déchiffré donne :
* Code dans ``byte_417010 ([ebp+var_14])``
```assembly
0:  80 f3 42                xor    bl,0x42
3:  88 1c 08                mov    BYTE PTR [eax+ecx*1],bl
6:  41                      inc    ecx
7:  c3                      ret
```

Nous observons donc un xor avec comme clé la valeur  ``0x42`` ce qui semble correspondre à une routine de déchiffrement.
De plus nous savons donc que le contenu de ``byte_417018`` est:
* Code dans ``byte_417018 ([ebp+var_20])``
```assembly
0:  33 c9                   xor    ecx,ecx
2:  8d 05 00 70 41 00       lea    eax,ds:0x417000
8:  c3                      ret
```

Grâce à ces deux fonctions nous affirmons donc que l'étiquette ``loc_411435`` charge leurs fonctions qu'ils avaient défini dans des tableaux dans leur code C, et que le ``call    [ebp+var_20]`` va placer dans eax l'adresse de ``byte_417000`` le message qui nécessitait d'être déchiffré.
Puis l'étiquette ``loc_411452`` itère ``ecx`` de 0 à 15 fois et fait appel à ``call    [ebp+var_14]`` qui va donc faire un xor entre la clé ``0x42`` et le contenu de ``bl`` qui vaudra donc ``byte_417000[ecx] - 1`` à cause du ``dec bl`` présent juste avant l'appel à ``call    [ebp+var_14]``.

```assembly
.text:00411435 loc_411435:                             ; CODE XREF: sub_411390+63j
.text:00411435                 mov     [ebp+var_14], offset byte_417010
.text:0041143C                 mov     [ebp+var_20], offset byte_417018
.text:00411443                 mov     esi, esp
.text:00411445                 call    [ebp+var_20]
.text:00411448                 cmp     esi, esp
.text:0041144A                 call    sub_411136
.text:0041144F                 mov     [ebp+var_2C], eax
.text:00411452
.text:00411452 loc_411452:                             ; CODE XREF: sub_411390+D9j
.text:00411452                 mov     bl, [eax+ecx]
.text:00411455                 dec     bl
.text:00411457                 mov     esi, esp
.text:00411459                 call    [ebp+var_14]
.text:0041145C                 cmp     esi, esp
.text:0041145E                 call    sub_411136
.text:00411463                 mov     [ebp+var_38], eax
.text:00411466                 cmp     ecx, 10h
.text:00411469                 jnz     short loc_411452
```

Expliquons maintenant comme déchiffrer ``byte_417018`` et ``byte_417010``

### Code caché

Le déchiffrement de ``byte_417018`` et ``byte_417010`` s'effectuent dans les deux étiquettes suivantes:
```assembly
.text:004113EF loc_4113EF:                             
.text:004113EF                 cmp     [ebp+var_8], 9
.text:004113F3                 jge     short loc_411435
.text:004113F5                 cmp     [ebp+var_8], 8
.text:004113F9                 jge     short loc_411417
.text:004113FB                 mov     eax, [ebp+var_8]
.text:004113FE                 movsx   ecx, byte_417010[eax]
.text:00411405                 xor     ecx, 12h
.text:00411408                 and     ecx, 0FFh
.text:0041140E                 mov     edx, [ebp+var_8]
.text:00411411                 mov     byte_417010[edx], cl
.text:00411417
.text:00411417 loc_411417:                            
.text:00411417                 mov     eax, [ebp+var_8]
.text:0041141A                 movsx   ecx, byte_417018[eax]
.text:00411421                 xor     ecx, 12h
.text:00411424                 and     ecx, 0FFh
.text:0041142A                 mov     edx, [ebp+var_8]
.text:0041142D                 mov     byte_417018[edx], cl
.text:00411433                 jmp     short loc_4113E6
```

La technique de déchiffrement est la même pour ``byte_417018`` et ``byte_417010`` sauf qu'on effectuera une itération de plus pour ``byte_417018`` (9 au lieu de 8).
Initialement le contenu de ``[ebp+var_8]`` vaut 0, et à chaque itération on va charger dans ``ecx`` le contenu de ``byte_417010`` (resp. ``byte_417010``) puis on va le xor avec la clé ``0x12`` puis on effectue un ``and 0xFF`` sur ecx.

### Remarques et algorithmes

Nous remarquons également beaucoup de séquences de ``cmp`` et ``jmp``  menant à rien et surtout pas utilisé, donc nous supposons également que leur code contient (peut-être pas volontairement) du code inutile.

Algorithme IDA Python de déchiffrement du message ``Je suis un virus``:
```python
ecx = 0
key = 0x42
msg = LocByName('byte_417000')
res = ''
while (ecx < 0x10):
	res += chr((Byte(msg + ecx) - 1) ^ key)
	ecx += 1
print(res)
```
Algorithme IDA Python de déchiffrement des fonctions en ``byte_417018`` et ``byte_417010``:
```python
ecx = 0
key = 0x12
mask = 0xFF
byte_417018 = LocByName('byte_417018')
byte_417010 = LocByName('byte_417010')
res_byte_417010 = ''
res_byte_417018 = ''

while (ecx <= 8):
	res_byte_417018 += hex(Byte(byte_417018 + ecx) ^ key & mask)
	if (ecx < 8):
		res_byte_417010 += hex(Byte(byte_417010 + ecx) ^ key & mask)
	ecx += 1
print(res_byte_417018 + '\n' + res_byte_417010)
```